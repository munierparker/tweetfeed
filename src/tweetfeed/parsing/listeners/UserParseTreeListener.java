/*
 * TweetFeed. Munier Parker, 2016.
 */
package tweetfeed.parsing.listeners;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.logging.Level;
import org.antlr.v4.runtime.Lexer;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.tree.ErrorNode;
import org.antlr.v4.runtime.tree.ParseTreeListener;
import org.antlr.v4.runtime.tree.TerminalNode;
import tweetfeed.TweetFeed;
import tweetfeed.tweet.User;
import tweetfeed.tweet.TweetRegistryManager;

/**
 *
 * @author Munier
 *
 * UserParseTreeListener receives events when CustomUserParser.java walks the ParseTree as generated by the
 * LexicalAnalyser looking for recognisable tokens in the user.txt file
 *
 * I did not have time to extend this grammar to be more robust so that (a) the users names can have spaces (b) It can
 * contain any 7-bit character
 *
 *
 */
public class UserParseTreeListener implements ParseTreeListener {

    //the lexical analyser that reads the user.txt file
    private Lexer lexer;
    //the previous node received from the lexical analyser
    private TerminalNode previousNode;
    //the current User object that is read from user.txt as the rest of the list is uncovered.
    private User currentUserBeingParsed;

    //a set of flags to decide how to display error output to the console
    private boolean printErrors = true;
    private boolean bypassUserInputOnError = false;
    private boolean firstTimeError = true;

    /**
     * Create a ParseTreeListener used with the Parser generated by the ANTLR grammar
     *
     * @param lexer the lexer object that will identify tokens in user.txt
     */
    public UserParseTreeListener(Lexer lexer) {
        this.lexer = lexer;
        this.currentUserBeingParsed = null;
        this.previousNode = null;
    }

    /**
     * When a node is encountered that is recognise and the associated token is returns. This method uses the ANTLR
     * grammar defined rules to identify when a
     *
     * @param tn The current token in the parse tree.
     */
    @Override
    public void visitTerminal(TerminalNode tn) {
        String lexerRuleName = this.getLexerRuleName(tn);

        switch (lexerRuleName) {
            case "ALPHANUMERIC": //When an alphanumeric is encountered
                if (this.previousNode != null) {
                    //check if the word "follows" was detected
                    if (this.getLexerRuleName(this.previousNode).equals("FOLLOWS")
                            //or if  comma was detected
                            || this.getLexerRuleName(this.previousNode).equals("COMMA")) {
                        //It means that there is a User to follow, so get that User from the name
                        User userToFollow = TweetRegistryManager.getInstance().getUser(tn.getText());
                        //then tell that user to follow the new user
                        this.currentUserBeingParsed.follow(userToFollow);
                    }
                }
                break;
            case "FOLLOWS": //If the word "follows" is detected
                if (this.getLexerRuleName(this.previousNode).equals("ALPHANUMERIC")) { //and this token is alphanumeric
                    //then the previous node was the User
                    this.currentUserBeingParsed = TweetRegistryManager.getInstance().
                            getUser(this.previousNode.getText());
                    //System.out.println("User retrieved:" + this.currentUserBeingParsed.getName());
                }
                break;

            //nothing needed here for now
            case "COMMA":
                break;
            case "NEWLINE":
                break;
            default:
                break;
        }
        this.previousNode = tn;
    }

    //Get the lexer rule name from the token
    public String getLexerRuleName(TerminalNode tokenNode) {
        return this.lexer.getVocabulary().getSymbolicName(tokenNode.getSymbol().getType());
    }

    /**
     * If an error occurs, tell the user: (a) which file (b) what the name of the error is and specifically which line
     * and index (c) how to fix the error for future (d) On a first time error what the known issues are
     *
     * @param en the Error Node
     *
     * NOTE: This block is not meant for Production Code but for the Alan Gray assessors.
     */
    @Override
    public void visitErrorNode(ErrorNode en) {
        if (!this.getLexerRuleName(en).equals("NEWLINE")) { //Newlines are knows issues, ignore them
            if (this.printErrors) {
                StringBuilder output = new StringBuilder();
                output.append(TweetFeed.ANSI_RED
                        + "-----------------------------------------------------------------\n");
                output.append(TweetFeed.ANSI_RED
                        + "An error was encountered while parsing the Tweets file.\n");
                output.append(TweetFeed.ANSI_RED
                        + "The token '" + this.getLexerRuleName(en));
                output.append(TweetFeed.ANSI_RED
                        + "' of [char] '" + (en.getText().equals("\n") ? "\\n" : en.getText()));
                output.append(TweetFeed.ANSI_RED
                        + "' is at line:" + en.getSymbol().getLine() + " and index: ");
                output.append(TweetFeed.ANSI_RED
                        + en.getSymbol().getTokenIndex());
                if (this.firstTimeError) {
                    output.append("\n\n" + TweetFeed.ANSI_RED
                            + "Modify the grammar (tweetfeed/grammars/UserFollow.g4)\n");
                    output.append(TweetFeed.ANSI_RED
                            + "with additional rules for improved fault tolerance.\n");
                    output.append("\n" + TweetFeed.ANSI_RED
                            + "Known issues: allow spaces & 7-bit chars in User's\n");
                    output.append(TweetFeed.ANSI_RED
                            + "name; ignoring new line characters at the beginning.");
                    this.firstTimeError = false;
                }
                output.append("\n" + TweetFeed.ANSI_RED
                        + "-----------------------------------------------------------------");
                System.out.println(output.toString());
                this.showErrorMenu();

            }
        }
    }

    /**
     * Show the user a menu to decide how to proceed with errors. NOTE: This block is not meant for Production Code but
     * for the Alan Gray assessors.
     */
    private void showErrorMenu() {
        String input = "";
        do {
            System.out.println(TweetFeed.ANSI_GREEN + "      MENU: SELECT AN OPTION");
            System.out.println(TweetFeed.ANSI_GREEN + "(<C> Continue and show future errors");
            System.out.println(TweetFeed.ANSI_GREEN + "(<I> Continue, but ignore future errors");
            System.out.println(TweetFeed.ANSI_GREEN + "(<E> Exit");
            System.out.println(TweetFeed.ANSI_RESET); //reset back to original colour scheme

            try {
                BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
                input = br.readLine();
            } catch (IOException e) {
                TweetFeed.TweetLogger.log(Level.SEVERE, e.getMessage());
                System.exit((0));
            }

        } while (!(input.equals("C") || input.equals("c")
                || input.equals("I") || input.equals("i")
                || input.equals("E") || input.equals("e")));

        switch (input) {
            case "C":
            case "c":
                break;
            case "I":
            case "i":
                this.printErrors = false;
                break;
            case "E":
            case "e":
                System.exit(0);
                break;
            default:
                this.showErrorMenu();
                break;
        }
    }

    @Override
    public void enterEveryRule(ParserRuleContext prc) {
        //System.out.println("Parser Enter Every Rule:" + prc.getText());
    }

    @Override
    public void exitEveryRule(ParserRuleContext prc) {
        //System.out.println("Exit Every Rule:" + prc.getText());
    }

}
